Stage 1:
    Inputs (fl[16], fh[16], symb[4], nsyms[5], LUT[addr:8,data:16)
    Outputs (UU[16], COMP_mux_1[1], VV[16], LUT_U_OUT[16], LUT_V_OUT[16]) 

        UU = (fl >> EC_PROB_SHIFT)    

        VV = (fh >> EC_PROB_SHIFT)       
        
        LUT_U_OUT = LUT[{nsyms-1, symb}]        // [EC_MIN_PROB*((nsyms-1)-(symb-1))]
        LUT_V_OUT = LUT[{nsyms-1, symb}]        // [EC_MIN_PROB*((nsyms-1)-(symb+0))]


        COMP_mux_1 (fl < CDF_PROB_TOP)

------------------------------------------------
Stage 2:
    Inputs (UU[16], COMP_mux_1[1], VV[16], in_range[16], in_low[16], LUT_U[16], LUT_V[16], UU[16], VV[16])
    Outputs (LOW[16], RANGE[16])
    
        RR = in_range >> 8
    
        u = (RR * UU >> 1) + LUT_U
        v = (RR * VV >> 1) + LUT_V
    
        LOW_1 = in_low + (in_range - u))
        LOW_2 = in_low
        
        RANGE_1 = u - v
        RANGE_2 = in_range - v

        mux_1_range (COMP_mux_1)        -> RANGE
            1: RANGE_1
            0: RANGE_2
            
        mux_1_low (COMP_mux_1)          -> LOW
            1: LOW_1
            0: in_low        

------------------------------------------------
Stage 3: 
    Inputs (LOW[16], RANGE[16], in_cnt[32])
    Outputs (LOW[16], RANGE[16], in_cnt[32], D[5], C_s0[32], M_s0[32])     
        
        D = lcz(RANGE)                   // instead of being defined as D = [16 - __builtin_clz(rng)], it can be just LCZ for 16 bits.
        C_s0 = in_cnt + 16
        M_s0 = [1 << (in_cnt + 16)] - 1
        
        
        
-----------------------------------------------
Stage 4:
    Inputs (LOW[16], RANGE[16], in_cnt[32], D[5], C_s0[32], M_s0[32])
    Outputs (LOW[16], RANGE[16], in_cnt[32], D[5], S[32], COMP_mux_2[1], COMP_mux_3[1], C_s0[32], M_s0[32], M_s8[32], C_s8[32], LOW_s8[16])
        
        S = in_cnt + D
        COMP_mux_2 = (S > 0) OR (S = 0)
        COMP_mux_3 = (S > 8) OR (S = 8)
        
        M_s8 = M_s0 >> 8
        C_s8 = C_s0 - 8
        LOW_s8 = LOW and M_s0
        
-----------------------------------------------
Stage 5:
    Inputs (LOW[16], RANGE[16], in_cnt[32], D[5], C_s0[32], M_s0[32], S[32], COMP_mux_2[1], COMP_mux_3[1], M_s8[32], C_s8[32], LOW_s8[16])
    Outputs (OUT_LOW[16], OUT_RANGE[16], OUT_CNT[32])
    
    MUX_3_low (COMP_mux_3)
        1: LOW_s8
        0: LOW
    MUX_3_c (COMP_mux_3)
        1: C_s8
        0: C_s0
    MUX_3_m (COMP_mux_3)
        1: M_s8
        0: M_s0
    
    OUT_LOW_1 = [MUX_3_low and MUX_3_m] << D
    OUT_LOW_2 = LOW << D
    
    MUX_2_low (COMP_mux_2)
        1: OUT_LOW_1
        0: OUT_LOW_2
    
    OUT_RANGE = RANGE << D
    
    OUT_CNT_1 = [MUX_3_c + D] - 24
    
    MUX_2_cnt (COMP_mux_2)
        1: OUT_CNT_1
        0: S
        
-----------------------------------------------
Leading Zero's counter

    G4_1 = (15 OR 14) OR (13 OR 12)
    G3_1 = 15 OR (!14 AND 13)
    G2_1 = !14 AND !12
    G1_1 = !(13 OR 12)
    
    G4_2 = (11 OR 10) OR (9 OR 8)
    G3_2 = 11 OR (!10 AND 9)
    G2_2 = !10 AND !8
    G1_2 = !(9 OR 8)
    
    G4_3 = (7 OR 6) OR (5 OR 4)
    G3_3 = 7 OR (!6 AND 5)
    G2_3 = !6 AND !4
    G1_3 = !(5 OR 4)
    
    G4_4 = (3 OR 2) OR (1 OR 0)
    G3_4 = 3 OR (!2 AND 1)
    
    // Q
    Q1_1 = G4_1 OR G4_2
    Q2_1 = G3_1 OR (G2_1 AND G3_2)
    Q3_1 = G3_1 AND G2_2
    Q4_1 = (15 OR 14) OR [G1_1 AND (11 OR 10)]
    Q5_1 = G1_1 AND G1_2
    Q6_1 = !G4_2
    
    Q1_2 = G4_3 OR G4_4
    Q2_2 = G3_3 OR (G2_3 AND G3_4)
    Q3_2 = (7 OR 6) OR [G1_3 AND (3 OR 2)]
    
    V = !(Q1_1 OR Q1_2)
    Z0 = ![Q2_1 OR (Q3_1 AND Q2_2)]
    Z1 = ![Q4_1 OR (Q5_1 AND Q3_2)]
    Z2 = ![G4_1 OR (Q6_1 AND G4_3)]
    Z3 = !Q1_1
        




